%%% PharmTeX Package, part of the PharmTeX platform.
%%% Copyright (C) 2021 Christian Hove Claussen (contact@pharmtex.org).
%%% This program is free software: You can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program (see file named LICENSE). If not, see <https://www.gnu.org/licenses/>.

%%% Define PharmTeX Package for LaTeX
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{PharmTeX}[\pharmtexdate\space v\pharmtexversion\space PharmTeX Package]

%%% Settings for the glossary
\RequirePackage[toc,translate=babel,hyperfirst=false]{glossaries}
\newcommand{\abbreviationname}{ABBREVIATION AND DEFINITION OF TERMS}
\newcounter{mycnt}
\makeglossaries
\renewcommand{\entryname}{Abbreviation}
\renewcommand{\descriptionname}{Definition}
\newlength\maxlength
\newlength\thislength
\newglossarystyle{mystyle}{%
  \renewenvironment{theglossary}%
     {
    \setlength{\maxlength}{0pt}%
    \forglsentries[\currentglossary]{\thislabel}%
    {%
       \settowidth{\thislength}{\glsentryshort{\thislabel}}%
       \ifdim\thislength>\maxlength
         \setlength{\maxlength}{\thislength}%
       \fi%  \@starttoc{lof}%
%}
    }%
    \settowidth{\thislength}{\hspace{1.5em} \hspace{1em}}%
    \begin{longtable*}{p{\maxlength+0.1\maxwidth}p{\maxwidth-\maxlength-4\tabcolsep-0.1\maxwidth}}}%
     {\end{longtable*}}%
  \renewcommand*{\glossaryheader}{}%
  \renewcommand*{\glsgroupheading}[1]{}%
  \renewcommand{\glossentry}[2]{%
    \glsentryitem{##1}\glstarget{##1}{\glossentryname{##1}} &
    \ifglossaryupper\Glossentrydesc{##1}\glspostdescription\space ##2\else\glossentrydesc{##1}\glspostdescription\space ##2\fi%
    \addtocounter{mycnt}{1}
    \tabularnewline
  }%
  \renewcommand{\subglossentry}[3]{%
     &
     \glssubentryitem{##2}%
     \glstarget{##2}{\strut}\glossentrydesc{##2}%
     \glspostdescription\space ##3%
     \tabularnewline
  }%
  \renewcommand*{\glsgroupskip}{\ifglsnogroupskip\else & \tabularnewline\fi}%
  \renewcommand*{\glossaryheader}{%
  \bfseries \entryname & \bfseries \descriptionname
    \tabularnewline
    \endhead
    \endfoot}%
}
\newcommand{\glsfile}[1]{\checkfile{#1}{GlsFile}\IfFileExists{\GlsFile.tex}{\ifmathimg\fixgls{\GlsFile}{1}\else\fixgls{\GlsFile}{0}\fi}{}}
\ifglosshyper
\else
\glsdisablehyper
\fi

%%% Define \ACRLONG command to allow uppercase of all first letters
\let\oldmakefirstuc\makefirstuc
\newcommand{\ACRLONG}[1]{%
\renewcommand*{\makefirstuc}[1]{%
  \def\gls@add@space{}%
  \mfu@capitalisewords##1 \@nil\mfu@endcap%
}%
\def\mfu@capitalisewords##1 ##2\mfu@endcap{%
  \def\mfu@cap@first{##1}%
  \def\mfu@cap@second{##2}%
  \gls@add@space%
  \oldmakefirstuc{##1}%
  \def\gls@add@space{ }%
  \ifx\mfu@cap@second\@nnil%
    \let\next@mfu@cap\mfu@noop%
  \else%
    \let\next@mfu@cap\mfu@capitalisewords%
  \fi%
  \next@mfu@cap##2\mfu@endcap%
}%
\Acrlong{#1}%
\let\makefirstuc\oldmakefirstuc%
}%

%%% Settings for eqnimg option
\newcommand{\eqnimgscalewin}{1}
\newcommand{\eqnimgscalelin}{1}
\ifeqnimg
\newcounter{subjob}
\newcommand{\myalignatnum}{}
\IfFileExists{eqnimg.txt}{
\RenewEnviron{align}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{align*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{alignat}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{alignat*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{equation}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{equation*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{eqnarray}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{eqnarray*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{gather}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{gather*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{multline}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{multline*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{flalign}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{flalign*}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\RenewEnviron{subequations}{\stepcounter{subjob}\input{\jobname-eqn-\thesubjob.tex}}
\AfterEndEnvironment{subequations}{\nlalign}
\renewcommand{\nlalign}{\vspace{-\baselineskip}}
}{
\renewenvironment{align}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{align}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{align}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{align*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{align*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{align*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{alignat}[1]{\gdef\myalignatnum{##1}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{alignat}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{alignat}{\myalignatnum}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{alignat*}[1]{\gdef\myalignatnum{##1}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{alignat*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{alignat*}{\myalignatnum}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{equation}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{equation}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{equation}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{equation*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{equation*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{equation*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{eqnarray}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{eqnarray}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{eqnarray}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{eqnarray*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{eqnarray*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{eqnarray*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{gather}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{gather}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{gather}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{gather*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{gather*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{gather*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{multline}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{multline}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{multline}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{multline*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{multline*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{multline*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{flalign}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{flalign}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{flalign}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{flalign*}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{flalign*}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{flalign*}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
\renewenvironment{subequations}{\gdef\myalignatnum{}\stepcounter{subjob}\filecontents{\jobname-eqn-\thesubjob.tex}}{\endfilecontents}\AfterEndEnvironment{subequations}{\saveeqnfile{\jobname-eqn-\thesubjob.tex}{subequations}{}{\jobname}{\thefontsize}{\eqnimgscalewin}{\eqnimgscalelin}}
}
\fi

\newcommand{\convimg}[1]{\ensuremath{#1}}
\ifmathimg
\ifcconvimg\else\convimgtrue\fi
\newwrite\myout
\newcounter{isubjob}
\newcommand{\domathimgload}{0}\IfFileExists{mathimg.txt}{\renewcommand{\domathimgload}{1}}{}
\newcommand{\domathimgmake}{0}\IfFileExists{\jobname.bbl}{\IfFileExists{mathimg.txt}{}{\renewcommand{\domathimgmake}{1}}}{}
\ifnum\domathimgmake=1
\ifconvimg
\renewcommand{\convimg}[1]{\protect\stepcounter{isubjob}\immediate\openout\myout=\jobname-math-\arabic{isubjob}.tex\immediate\write\myout{\detokenize{#1}}\immediate\closeout\myout}
\fi
\catcode`\$=13%`
\def$#1${\protect\stepcounter{isubjob}\immediate\openout\myout=\jobname-math-\arabic{isubjob}.tex\immediate\write\myout{\detokenize{#1}myuniquefontstart=\thefontsize{}myuniquefontend}\immediate\closeout\myout}
\global\let\tikz@ensure@dollar@catcode=\relax
\fi
\ifnum\domathimgload=1
\ifconvimg
\renewcommand{\convimg}[1]{\protect\stepcounter{isubjob}\ensuremath{\input{\jobname-math-\arabic{isubjob}.tex}}}
\fi
\catcode`\$=13%`
\def$#1${\protect\stepcounter{isubjob}\ensuremath{\input{\jobname-math-\arabic{isubjob}.tex}}}
\global\let\tikz@ensure@dollar@catcode=\relax
\fi
\fi

\ifmathimg\else
\ifconvimg
\newwrite\myout
\newcounter{isubjob}
\newcommand{\domathimgload}{0}\IfFileExists{mathimg.txt}{\renewcommand{\domathimgload}{1}}{}
\newcommand{\domathimgmake}{0}\IfFileExists{\jobname.bbl}{\IfFileExists{mathimg.txt}{}{\renewcommand{\domathimgmake}{1}}}{}
\ifnum\domathimgmake=1
\renewcommand{\convimg}[1]{\protect\stepcounter{isubjob}\immediate\openout\myout=\jobname-math-\arabic{isubjob}.tex\immediate\write\myout{\detokenize{#1}}\immediate\closeout\myout}
\fi
\ifnum\domathimgload=1
\renewcommand{\convimg}[1]{\protect\stepcounter{isubjob}\ensuremath{\input{\jobname-math-\arabic{isubjob}.tex}}}
\fi
\fi
\fi

%%% Perl custom commands

\IfFileExists{noperl.txt}{\newcommand{\dopharmtexperl}{0}}{\newcommand{\dopharmtexperl}{1}}

\ifnum\dopharmtexperl=1

\RequirePackage{perltex}
\perlnewcommand{\findartifact}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use PDF::API2;
use File::Copy qw(copy);
my $artid = $_[0];
my $docopy = $_[1];
if ($artid =~ /RA[0-9]+/) {
	opendir D, '.';
	my @filelist = grep(/.{1,}\.(?!paz)/i, grep(/.{1,}\.(?!pay)/i, grep(/.{1,}\.(?!pax)/i, grep(/$artid\_.{1,}/i, readdir D))));
	closedir D;
	my $nl = scalar @filelist;
	if ($nl > 0) {return "\\renewcommand{\\ioutput}{0}\\renewcommand{\\fname}{$filelist[0]}";}
	else {return "\\renewcommand{\\ioutput}{0}\\let\\fname\\empty";}
}
else {
	my ($fname) = $artid =~ /\/*([^\/]+?)$/;
	my ($pth) = $artid =~ /(.*)\//;
	my ($ext) = $artid =~ /\.([^.]+?)$/;
	$pth =~ s/^\//s-/g;
	$pth =~ s/\//-/g;
	$pth =~ s/([a-zA-Z])\:/$1/g;
	$pth =~ s/\./d/g;
	if (length($pth)>0) {
		$fname = "pmxinputfiles/$fname---$pth.$ext";
	} else {
		$fname = "pmxinputfiles/$fname";
	}
	if ($docopy==1) {
		if (!-e 'pmxinputfiles') { mkdir('pmxinputfiles'); }
		if (!-f $fname) { if (-f $artid) { copy $artid, $fname; } }
		$artid = $fname;
	}
	if (-f $artid) {
		my ($ext) = $artid =~ /\.([^.]+?)$/; my $pages;
		if ($ext eq 'pdf') {
			my $pdf = PDF::API2->open($artid);
			$pages = $pdf->pages;
		}
		else {
			$pages = 1;
		}
		if ($pages > 0) {
			return "\\renewcommand{\\ioutput}{1}\\renewcommand{\\fname}{$artid}";
		}
		else {
			return "\\renewcommand{\\ioutput}{1}\\let\\fname\\empty";
		}
	}
	else {
		return "\\renewcommand{\\ioutput}{1}\\let\\fname\\empty";
	}
}}
\perlnewcommand{\dotwice}{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
open(my $file, '>:utf8', 'dotwice');
close $file;
return
}
\perlnewcommand{\includetex}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', $file; my $str = do { local $/; <$lines> }; close $lines;

$str =~ s/^.*\\begin\{document\}\n*//s;
$str =~ s/\n*\\references.*//s;
$str =~ s/\n*\\appendix.*//s;
$str =~ s/\n*\\itemlist.*//s;
$str =~ s/\n*\\end\{document\}.*//s;

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ( $str =~ /[^$asciichar]+/ ) { $mkfile = 1; $str = $tmpstr; }

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', 'input.tmp.txt');
	print FILE "\n$str\n";
	close(FILE);
	return "\\input{input.tmp.txt}";
} else {
	return "\n$str\n";
}}
\perlnewcommand{\inputtext}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', $file; my $str = do { local $/; <$lines> }; close $lines;

$str =~ s/\n$//s;

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ( $str =~ /[^$asciichar]+/ ) { $mkfile = 1; $str = $tmpstr; }

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', 'input.tmp.txt');
	print FILE "$str\\ifitemid\\fi\\footnote{\\itemid{#1}}\\ignorespaces";
	close(FILE);
	return "\\input{input.tmp.txt}";
} else {
	return "$str\\ifitemid\\fi\\footnote{\\itemid{#1}}\\ignorespaces";
}}
\perlnewcommand{\fixbib}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];

if ( -e 'fixfiles' ) {

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', "$file.bib"; my $str = do { local $/; <$lines> }; close $lines;
if (($str =~ /[^\\] *\&/) | ($str =~ /[^\\] *\_/)) {
	$mkfile = 1;
	# $str =~ s/abstract *=[^\n]+\n\t* *//g;
	# $str =~ s/keywords *=[^\n]+\n\t* *//g;
	$str =~ s/\\\&/\&/g;
	$str =~ s/\&/\\\&/g;
}

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file.bib. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ($mkfile==1) { $str = $tmpstr; }

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', "$file-tmpfixfile.bib");
	print FILE "$str";
	close(FILE);
	return "\\edef\\RefFile{$file-tmpfixfile}";
} else {
	return "\\edef\\RefFile{$file}";
}

} else {

if ( -e "$file-tmpfixfile.bib" ) {
	return "\\edef\\RefFile{$file-tmpfixfile}";
} else {
	return "\\edef\\RefFile{$file}";
}

}}
\perlnewcommand{\fixgls}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];
my $dodollar = $_[1];

if ( -e 'fixfiles' ) {

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', "$file.tex"; my $str = do { local $/; <$lines> }; close $lines;

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file.tex. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }

if ( $dodollar == 1 ) {
	$tmpstr = $str; $tmpstr =~ s/\\\$/myveryuniquedollar/g;
	$tmpstr =~ s/\$([^\$]*)\$/\\ensuremath\{$1\}/g;
	if ( defined $1 ) { $mkfile = 1; $str = $tmpstr; }
	$str =~ s/myveryuniquedollar/\\\$/g;
}

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', "$file-tmpfixfile.tex");
	print FILE "$str";
	close(FILE);
	return "\\loadglsentries{$file-tmpfixfile}";
} else {
	return "\\loadglsentries{$file}";
}

} else {

if ( -e "$file-tmpfixfile.tex" ) {
	return "\\loadglsentries{$file-tmpfixfile}";
} else {
	return "\\loadglsentries{$file}";
}

}}
\perlnewcommand{\checkfile}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];
my $name = $_[1];
$str =~ s/\.[^\.]+$//g;
return "\\edef\\$name\{$str\}";
}
\perlnewcommand{\includecsv}[9]{
use 5.010;
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use List::Util qw(sum min max);
use Encoding::FixLatin qw(fix_latin);

my $nhead = $_[0];
my $file = $_[1];
my $sepstr = $_[2];
my $colspec = $_[3];
my $key = $_[4];
my $label = $_[5];
my $newhead = $_[6];
my $dotight = $_[7];
my $domake = $_[8];

$label =~ s/,/myveryuniquecomma/g;

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

# Apply filter for streamlining text encoding in file
my $str; my $fh;
if ($file ne '') {
	open $fh, '<:raw', $file; $str = do { local $/; <$fh> }; close $fh;
	$str=~ s/(\n|^)\%.*//g; # remove commented lines
	$str =~ s/(\n|^)(\n)/$1/g; # remove empty lines
	$str =~ s/(^|.+)([^\\]\%.*)/$1/g; # remove end of line comments
	$str =~ s/\n?\z/\n/; # make sure that the last line break is there
} else {
	$str = $newhead; $newhead = '';
}
if ( $domake>0 ) { $str =~ s/\\\\/\\\\\n/g; }

# Harmonize horizontal lines
$str =~ s/\\hline/\\midrule/g;
$str =~ s/\\toprule/\\midrule/g;
$str =~ s/\\bottomrule/\\midrule/g;
$str =~ s/\\pmxtoprule/\\midrule/g;
$str =~ s/\\pmxmidrule/\\midrule/g;
$str =~ s/\\pmxbottomrule/\\midrule/g;
$str =~ s/\\cline/\\cmidrule/g;
$str =~ s/\\pmxcline/\\cmidrule/g;

$str =~ s/ *\\begin *\{table\}\[[a-zA-Z]+\]//g;
#$str =~ s/ *\\centering//g;
$str =~ s/\\tabularnewline/\\\\/g;
$str =~ s/ *\\caption *\{[a-zA-Z ]+\}//g;
$str =~ s/ *\\begin *\{tabular\}[^ ]+//g;
$str =~ s/\\end *\{tabular\}//g;
$str =~ s/\\label *\{[a-z\:]+\}//g;
$str =~ s/\\end *\{table\}\%*//g;
$str =~ s/\\bigstrut *(\[[a-z]\])*//g;

$str =~ s/\\textbackslash *\{\}/myunback/g;
$str =~ s/\\\#/myunhash/g;
$str =~ s/\\\%/myunperc/g;
$str =~ s/\\\_/myununder/g;
$str =~ s/\\\^ *(\{\})*/myunhat/g;
$str =~ s/\\&/myunand/g;
$str =~ s/\\\{/myunleft/g;
$str =~ s/\\\}/myunright/g;
$str =~ s/\\\$/myundollar/g;
$str =~ s/\~/myuntilde/g;

$str =~ s/\\multicolumn *\{1\}\{[\|]*[a-z]\{[0-9a-z\.]+\}[\|]*\}\{([^\&\\\\]+)\}/$1/g;
$str =~ s/\\multicolumn *\{1\}\{[\|]*[a-z][\|]*\}\{([^\&\\\\]*)\}/$1/g;
# $str =~ s/(\\multirow *\{[0-9]+\})(\[[0-9]+\])/$1/g;

$str =~ s/myunback/\\textbackslash \{\}/g;
$str =~ s/myunhash/\\\#/g;
$str =~ s/myunperc/\\\%/g;
$str =~ s/myununder/\\\_/g;
$str =~ s/myunhat/\\\^{}/g;
$str =~ s/myunand/\\&/g;
$str =~ s/myunleft/\\\{/g;
$str =~ s/myunright/\\\}/g;
$str =~ s/myundollar/\\\$/g;
$str =~ s/myuntilde/\\string\~/g;

$str =~ s/\\textbackslash *\{\}newline\{\}/\\newline\{\}/g;

if ( $domake>0 ) { 
	$str=~ s/\r\n?/\n/g;
	$str=~ s/ *\n/\n/g;

	$str=~ s/(\n|^)\%.*//g; # remove commented lines
	$str =~ s/(\n|^)(\n)/$1/g; # remove empty lines
	$str =~ s/(^|.+)([^\\]\%.*)/$1/g; # remove end of line comments
	$str =~ s/\n?\z/\n/; # make sure that the last line break is there
}

my $x; my $i; my $modcolspec;
my $sep = $sepstr; my $sepp; $i=0; my $j=0;
if ($sepstr eq 'comma') {$sep = ','; $sepp = ",";}
elsif ($sepstr eq 'semicolon') {$sep = ';'; $sepp = ";";}
elsif ($sepstr eq 'pipe') {$sep = '\|'; $sepp = "\|";}
elsif ($sepstr eq 'tab') {$sep = '\t'; $sepp = "\t";}
elsif ($sepstr eq 'texcomma') {$sep = ','; $sepp = ",";}
elsif ($sepstr eq 'texsemicolon') {$sep = ';'; $sepp = ";";}
elsif ($sepstr eq 'texpipe') {$sep = '\|'; $sepp = "\|";}
elsif ($sepstr eq 'textab') {$sep = '\t'; $sepp = "\t";}
elsif ($sepstr eq 'tex') {$sep = 'myveryuniquetexseparator'; $sepp = "myveryuniquetexseparator";}
else {die "Undefined table separator! Use only (tex)comma, (tex)semicolon, (tex)pipe), (tex)tab, and tex!";}

# Further process file lines
if ($sepstr eq 'tex') {
	$str =~ s/\n/ /g;
	$str =~ s/\\\\\*(( *\\midrule *)*)/$1\n/g;
	$str =~ s/\\\\(( *\\midrule *)*)/$1\n/g;
	$str =~ s/( *\n *)+/\n/g;
	$str =~ s/^ +//g;
	$str =~ s/\n +/\n/g;
	$str =~ s/ +\n/\n/g;
	$str =~ s/ +$//g;
	$str =~ s/\n+/\n/g;
	$str =~ s/\n *\\newline *{}/\n/g;
	$str =~ s/\& *\\newline *{}/\&/g;
	$str =~ s/\\newline *{} *\&/\&/g;
	$str =~ s/([^\\])\&/$1 myveryuniquetexseparator/g;
}
$str =~ s/\n?\z//;
my @lines = split "\n", $str; my $nline = scalar @lines - 1;

my @ishline; my $tmpstr;
for ($i=0; $i <= $nline; $i++) {
	$lines[$i] =~ s/\n//g;
	($ishline[$i]) = $lines[$i] =~ m/(( *\\midrule *)+)/;
	$lines[$i] =~ s/\\midrule//g;
}

# Get rid of spaces in $colspec
$colspec =~ s/ //g;

# Determine number of columns in file
my @ncoltots = 0; my $ncoltot;
for ($i=0; $i <= $nline; $i++) {
	$ncoltots[$i] = () = $lines[$i] =~ /$sep/gi;
	$ncoltots[$i] = $ncoltots[$i] + 1;
}
$ncoltot = max(@ncoltots);

# Use all columns in file if nothing specified by user
if ( $colspec eq '' ) { $colspec = 'L' x $ncoltot; }

# Check for multicolumn and column swapping
if ((index($str, '\multicolumn') != -1) && (index($colspec, '[') != -1)) { die "Column swapping ($colspec) not supported with merged columns (multicolumn)!"; }

# Get rid of spaces in $colspec
$colspec =~ s/ //g;

# Assume column number = position in input string, if no [column] is present
$modcolspec = $colspec;
$modcolspec =~ s/([\d\.]+)(pt)/$1uu1/g;
$modcolspec =~ s/([\d\.]+)(pc)/$1uu2/g;
$modcolspec =~ s/([\d\.]+)(in)/$1uu3/g;
$modcolspec =~ s/([\d\.]+)(bp)/$1uu4/g;
$modcolspec =~ s/([\d\.]+)(cm)/$1uu5/g;
$modcolspec =~ s/([\d\.]+)(mm)/$1uu6/g;
$modcolspec =~ s/([\d\.]+)(dd)/$1uu7/g;
$modcolspec =~ s/([\d\.]+)(cc)/$1uu8/g;
$modcolspec =~ s/([\d\.]+)(sp)/$1uu9/g;
$modcolspec =~ s/([\d\.]+)(ex)/$1uu10/g;
$modcolspec =~ s/([\d\.]+)(em)/$1uu11/g;
my @modcols = $modcolspec =~ /\|?[A-Za-z][u\{\}\[\]\d\.]*\|?/xg;
$i = 1;
foreach $x (@modcols) {
	$x =~ s/(\|?[A-Za-z])(\{[\d\.]+uu[0-9]+\}\|?)$/$1\[$i\]$2/g;
	$x =~ s/(\|?[A-Za-z])(\{[\d\.]+\}\|?)$/$1\[$i\]$2/g;
	$x =~ s/(\|?[A-Za-z]\|?)$/$1\[$i\]/g;
	$i = $i + 1;
}
$modcolspec = "@modcols"; $modcolspec =~ s/ //g;
$modcolspec =~ s/uu1/pt/g;
$modcolspec =~ s/uu2/pc/g;
$modcolspec =~ s/uu3/in/g;
$modcolspec =~ s/uu4/bp/g;
$modcolspec =~ s/uu5/cm/g;
$modcolspec =~ s/uu6/mm/g;
$modcolspec =~ s/uu7/dd/g;
$modcolspec =~ s/uu8/cc/g;
$modcolspec =~ s/uu9/sp/g;
$modcolspec =~ s/uu10/ex/g;
$modcolspec =~ s/uu11/em/g;
$colspec = $modcolspec;

my $ncolinp = scalar @modcols;

my $nsep = length($sepp); my $colorder = '';
if ($nhead < 1) { $nhead = 1; }
if (($sepstr eq 'comma') || ($sepstr eq 'semicolon') || ($sepstr eq 'pipe') || ($sepstr eq 'tab')) {
	for ($i=0; $i <= $nline; $i++) { $lines[$i] =~ s/([^$sep\n]{1,})/\\detokenize{$1}/g;} # the "-1" accounts for the description line
}
if (($sepstr ne 'comma') && ($sepstr ne 'texcomma')) {for ($i=0; $i <= $nline; $i++) {$lines[$i] =~ s/,/myveryuniquecomma/g;}}
if (($sepstr ne 'tab') && ($sepstr ne 'textab')) {for ($i=0; $i <= $nline; $i++) {$lines[$i] =~ s/\t/myveryuniquetab/g;}}

my @cols = $colspec =~ /\[(.*?)\]/xg; my $ncol = scalar @cols - 1; my $maxcol = max(@cols);
my @fields; my @newline; $str; my @colseq = (1..$ncoltot); my $docol;

if (@cols ~~ @colseq) {$docol = 0;} else {
	$docol = 1;
	if ($maxcol <= $ncoltot) {
		for ($i=0; $i <= $nline; $i++) {
			@fields = split("$sep", $lines[$i]);
			for ($j=0; $j <= $ncol; $j++) {
				$newline[$j] = $fields[$cols[$j]-1];
			}
			$lines[$i] = join("$sepp", @newline);
		}
		$colorder = "@cols "; $colorder = substr($colorder, 0, -1); $colorder = "Columns [$colorder] out of $ncoltot";
	}
	else {die "Too many input columns specified in \\pmxtable compared to contents of CSV file!";}
}
$colspec =~ s/\[(.*?)\]//g;

$lines[0] = "$lines[0] myveryuniquenewline\n";
for ($i=1; $i <= $nline; $i++) {
	$lines[$i] = "$ishline[$i-1] $lines[$i] myveryuniquenewline\n";
	$lines[$i] =~ s/ +/ /g;
}
$lines[-1] = "$lines[-1] $ishline[-1]\n";

my @header = @lines[0..$nhead-1];
my @body = @lines[$nhead..$nline];

$header[0] =~ s/^ *\\midrule//g;
$body[0] =~ s/^ *\\midrule//g;
$body[-1] =~ s/ *\\midrule *$//g;
$body[-1] =~ s/^ *myveryuniquenewline\n.*//g; # fix issue with \\ \midrule at end of table code causing blank line at end of table

if ($nhead < 1) { $nhead = 1; }
for ($i=0; $i <= $nhead-1; $i++) {
	$header[$i] =~ s/$sep/ \& /g;
}
for ($i=0; $i <= $nhead-2; $i++) {
	$header[$i] =~ s/myveryuniquenewline/ \\\\/g; # \\* keeps table "more together" with less splitting over pages as opposed to \\
}
for ($i=0; $i <= $nline-$nhead; $i++) {
	$body[$i] =~ s/$sep/ \& /g;
}
for ($i=0; $i <= $nline-$nhead; $i++) {
	$body[$i] =~ s/myveryuniquenewline/ \\\\/g;
}
for ($i=0; $i <= $nhead-1; $i++) { $header[$i] =~ s/myveryuniquenewline//g; }
for ($i=0; $i <= $nline-$nhead; $i++) { $body[$i] =~ s/myveryuniquenewline//g; }

my $substnote = ''; my $headnote; my $colnote;
if ($nhead == 1) {$headnote = "Line 1 substituted";};
if ($nhead > 1) {$headnote = "Lines 1--$nhead substituted";}
if ($newhead ne '') {@header = $newhead; $substnote = "$substnote $headnote.\\xspace";}
if (($ncolinp < $ncoltot) || ($docol == 1)) {$substnote = "$substnote $colorder.\\xspace";}

# Assume scale = 1 for unscaled columns (without {#})
my $newcolspec = $colspec; my $sum;
my @newcols = $newcolspec =~ /\|?[A-Za-z][\{\}\[\]\d\.]*\|?/xg;
foreach $x (@newcols) {
	$x =~ s/([A-Z])(\|?)$/$1\{1\}$2/g;
	$x =~ s/L\{([0-9\.]*?[a-zA-Z]+)\}/O\{$1\}/g;
	$x =~ s/R\{([0-9\.]*?[a-zA-Z]+)\}/P\{$1\}/g;
	$x =~ s/C\{([0-9\.]*?[a-zA-Z]+)\}/Q\{$1\}/g;
}
my @colspecnum = @newcols;
my @colspecalign = @newcols;
my @colspecleft = @newcols;
my @colspecright = @newcols;
for ($i=0; $i <= $ncol; $i++) {
	$colspecnum[$i] =~ s/\|*[LRC]\{([0-9\.]*)\}\|*/$1/g;
	$colspecalign[$i] =~ s/\|*([LRC])\{[0-9\.]*\}\|*/$1/g;
	$colspecleft[$i] =~ s/(\|*)[LRC]\{[0-9\.]*\}\|*/$1/g;
	$colspecright[$i] =~ s/\|*[LRC]\{[0-9\.]*\}(\|*)/$1/g;
	
}
$sum = 0; for ($i=0; $i <= $ncol; $i++) { $sum = $sum + $colspecnum[$i]; }
for ($i=0; $i <= $ncol; $i++) {
	if ($newcols[$i] =~ /\|*[LRC]\{([0-9\.]*)\}\|*/){
		$colspecnum[$i] = $colspecnum[$i]/$sum;
		$newcols[$i] = "$colspecleft[$i]$colspecalign[$i]\{$colspecnum[$i]\}$colspecright[$i]";
	}
}
$newcolspec = "@newcols"; $newcolspec =~ s/ //g;

$colspec = $newcolspec;

# Check for vertical lines
my $dovert;
if (index($colspec, '|') != -1) { $dovert = 1 } else { $dovert = 0; }

# Space between columns
my $multisepspace = '';
my $sepspace = '';
if ($dotight == 1) {
	@cols = $colspec =~ /\|?[A-Za-z][u\{\}\d\.]*\|?/xg;
	$ncol = scalar @cols - 1;
	for ($i=0; $i <= $ncol; $i++) {
		$cols[$i] =~ s/(\|)?([A-Za-z][u\{\}\d\.]*)(\|)?/$1\@{}$2\@{}$3/g;
	}
	$colspec = "@cols"; $colspec =~ s/ //g;
	$sepspace = "\\setlength\{\\tabcolsep\}\{2pt\}";
	$multisepspace = "\@\{\}";
}

my $nrowhead = scalar @header;
my $nrowbody = scalar @body;
my $ncoli; my @cells; my $I = 0; my $J; my $k; my $colalign; my $textalign;

if ($nrowhead>0) {
for ($i=0; $i < $nrowhead; $i++) {
	@cells = split "&", $header[$i];
	$ncoli = scalar @cells - 1;
	for ($j=0; $j <= $ncoli; $j++) {
		if ($cells[$j] =~ /\\multicolumn/){
			if ($colspecalign[$I] eq 'L') {$colalign = '\raggedright'; $textalign = '';} elsif ($colspecalign[$I] eq 'R') {$colalign = '\raggedleft'; $textalign = '';} else {$colalign = '\centering'; $textalign = '\centering';}
			($J) = $cells[$j] =~ /\\multicolumn *\{ *([0-9]+) *\}/;
			$sum = 0;
			for ($k=$I; $k < $I+$J; $k++) { $sum = $sum + $colspecnum[$k]; }
			$cells[$j] =~ s/\\multicolumn *\{ *([0-9]+) *\} *\{ *(\|*) *\= *(\|*) *\}/\\multicolumn\{$1\}\{$2$multisepspace\>\{\\hsize\=\\dimexpr$sum\\hsize+$1\\tabcolsep$colalign\\arraybackslash\}X$multisepspace$3\}/g;
			if ($colspecalign[$I] eq 'C') { $cells[$j] =~ s/(\\multirow.*?\{ *[0-9]* *\} *\{ *\= *\} *\{)/$1$textalign/g; } #}
			$I = $I + $J;
		} else {
			$I = $I + 1;
		}
	}
	$I = 0;
	$header[$i] = join("&", @cells);
}
}
if ($nrowbody>0) {
for ($i=0; $i < $nrowbody; $i++) {
	@cells = split "&", $body[$i];
	$ncoli = scalar @cells - 1;
	for ($j=0; $j <= $ncoli; $j++) {
		if ($cells[$j] =~ /\\multicolumn/){
			if ($colspecalign[$I] eq 'L') {$colalign = '\raggedright'; $textalign = '';} elsif ($colspecalign[$I] eq 'R') {$colalign = '\raggedleft'; $textalign = '';} else {$colalign = '\centering'; $textalign = '\centering';}
			($J) = $cells[$j] =~ /\\multicolumn *\{ *([0-9]+) *\}/;
			$sum = 0;
			for ($k=$I; $k < $I+$J; $k++) { $sum = $sum + $colspecnum[$k]; }
			$cells[$j] =~ s/\\multicolumn *\{ *([0-9]+) *\} *\{ *(\|*) *\= *(\|*) *\}/\\multicolumn\{$1\}\{$2$multisepspace\>\{\\hsize\=\\dimexpr$sum\\hsize+$1\\tabcolsep$colalign\\arraybackslash\}X$multisepspace$3\}/g;
			if ($colspecalign[$I] eq 'C') { $cells[$j] =~ s/(\\multirow.*?\{ *[0-9]* *\} *\{ *\= *\} *\{)/$1$textalign/g; } #}
			$I = $I + $J;
		} else {
			$I = $I + 1;
		}
	}
	$I = 0;
	$body[$i] = join("&", @cells);
}
}

my $vertstr = '';
if ($dovert == 1) { $vertstr = '\aboverulesep=0ex\belowrulesep=0ex\renewcommand{\arraystretch}{1.4}'; }

my $retstr = "
$sepspace
\\renewcommand{\\tmpsubstnote}{\\ifsubstnote$substnote\\fi}
\\renewcommand{\\csvtable}{
$vertstr
\\begin{tabularx}{\\maxwidth}{$colspec} \\tablabel{$label}{$key}
	\\ifthenelse{\\equal{\\tabletopnote}{}}{}{\\\\\\multicolumn{$ncoltot}{c}{\\textbf{\\normalsize\\tabletopnote}}}\\\\\\toprule
	 @header \\\\\\midrule\\endfirsthead\\caption[]{$label}\\\\\\toprule
	 @header \\\\\\midrule\\endhead
	\\endfoot
	\\gettablewidth\\gettablemaxwidth
	\\endlastfoot
	 @body
\\end{tabularx}
\\vspace{-1.2\\baselineskip}
}";
$retstr =~ s/ +/ /g;

$retstr =~ s/(\n *)\[/$1\{\[\}/g;
$retstr =~ s/[\t,\n]//g;
$retstr =~ s/myveryuniquecomma/,/g;
$retstr =~ s/myveryuniquetab/\t/g;

my $mkfile = 0; $str = $retstr;
$str = "\\catcode`\\%=12 \\catcode`\\#=12 $str \\catcode`\\%=14 \\catcode`\\#=6";

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ( $str =~ /[^$asciichar]+/ ) { $mkfile = 1; $str = $tmpstr; }

if ($domake==2){
	$str =~ s/\\\\ \\end{tabularx}/\\\\ \\bottomrule \\end{tabularx}/g;
} else {
	my $descstr = "\\ifnum\\dodescription=1\\multicolumn{\\ltcols}{l}{\\hspace{\\dimexpr-0.21cm+\\pmxtabcolsep-\\tabcolsep}\\makebox[0pt][l]{\\parbox{\\tptlwidth}{\\rule[2mm]{\\tptlwidthh}{1pt}\\newline\\ifitemid\\ifnum\\istextable=1\\ifshowinlinetable\\mytableitemnumber.\\xspace\\fi\\else\\mytableitemnumber.\\xspace\\fi\\fi\\tmpsubstnote\\myfloatdescription}}}\\else\\bottomrule\\fi";
	$str =~ s/\\\\ *\\end{tabularx}/\\\\* $descstr \\end{tabularx}/g; # Add description to table
}

$str =~ s/\\\\/\\tabularnewline/g;

$str =~ s/\\multicolumn\{1\}\{c\}\{(.*?)\}/\\centering $1/g;
$str =~ s/\\multicolumn\{1\}\{r\}\{(.*?)\}/\\raggedleft $1/g;

$str =~ s/\\&/myunand/g;
$str =~ s/\&/\\stepcounter{pmxcolumnnumber}\&/g;
$str =~ s/\\tabularnewline/\\setcounter{pmxcolumnnumber}{1}\\tabularnewline/g;
$str =~ s/myunand/\\&/g;

# open(FILE, '>:utf8', 'debug.txt');
# print FILE "$str";
# close(FILE);

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', 'file.tmp.txt');
	print FILE "$str";
	close(FILE);
	return "\\pmxinput{file.tmp.txt}";
} else {
	return "$str";
}}
\perlnewcommand{\includemetacsv}[7]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use File::stat;
use POSIX qw(strftime);

my $afiles = $_[0];
my $rfiles = $_[1];
my $nitems = $_[2];
my $itemartifact = $_[3];
my $itemrfile = $_[4];
my $docopy = $_[5];
my $dotime = $_[6];
my $nhead = 1;
my $header = "ITEM & PATH & UPDATE (GMT)";
my $ncoltot = 2;
my $i;
sub uniq { my %seen; grep !$seen{$_}++, @_; }
my $itemnumbers = "$itemartifact;$itemrfile";
$itemnumbers =~ s/ *//g;
$itemnumbers =~ s/^;//g;
my @itemnum = split ";", $itemnumbers;

# Artifacts
my @af = split ",", $afiles; my $na = scalar @af;
my $nl; my @aff; my @tmpfile; my @isaf = ("1") x $na;
for ($i=0; $i <= $na-1; $i++) { @tmpfile = glob $af[$i] . "_*"; $aff[$i] = @tmpfile[0]; }
for ($i=0; $i <= $na-1; $i++) { $af[$i] = "Artifact ID $af[$i]"; }

# Inline/R files
my @rf = split "myveryuniqueseparator", $rfiles; @rf = @rf[1..$#rf]; my @rff;
@rff = (@aff, @rf); @rf = (@af, @rf);
my @items = (1..$nitems);
my $nr = scalar @rf; my @newlines; my @isrf = ("0") x $nr;
@isaf = (@isaf, @isrf);

my @delfiles; my $ext; my $name;
open(FILE, '>:utf8', 'delauxitems.pl');
for ($i=0; $i <= $nr-1; $i++) {
	($ext) = $rff[$i] =~ /^.+\.([^.]+)$/;
	($name) = $rff[$i] =~ /(^.+)\.[^.]+$/;
	if ($ext eq "pdf") {
		$delfiles[$i] = "\"$name.pax\", \"$name.pay\", \"$name.paz\"";
	}
}
my $allfile = join( ', ', @delfiles );
print FILE "use strict;\nuse warnings;\nuse open OUT => ':raw';\nbinmode(STDOUT, \":utf8\");$allfile";
close(FILE);

# Initialize some variables
my $iid; my $fname; my $pth; my $checkfile;
my $sec; my $min; my $hour; my $mday; my $mon; my $year; my $wday; my $yday; my $isdst; my $tmpstr;
my @times; my @timesn; my @idx;

# Determine modification times
if ($nr > 0) {
	for ($i=0; $i <= $nr-1; $i++) {
		if ($docopy==1) {
			($fname) = $rff[$i] =~ /\/*([^\/]+?)$/;
			($pth) = $rff[$i] =~ /(.*)\//;
			($ext) = $rff[$i] =~ /\.([^.]+?)$/;
			$pth =~ s/\//-/g;
			$pth =~ s/([a-zA-Z])\:/$1/g;
			$pth =~ s/\./d/g;
			if (length($pth)>0) {
				$checkfile = "pmxinputfiles/$fname---$pth.$ext";
			} else {
				$checkfile = "pmxinputfiles/$fname";
			}
		} else {
			$checkfile = $rff[$i];
		}
		
		if (-e $checkfile) {
			$timesn[$i] = stat($checkfile)->mtime;
			$times[$i] = strftime('%Y-%m-%d %H:%M', gmtime( $timesn[$i] ) );
		} else {
			$timesn[$i] = "MISSING";
			$times[$i] = "MISSING";
		}
	}
}

# Sort by item number or time
if ($dotime==1) {
	@idx = sort { $timesn[$b] <=> $timesn[$a] } 0 .. $#timesn;
} else {
	@idx = sort { $itemnum[$a] <=> $itemnum[$b] } 0 .. $#itemnum;
}
@items = @items[@idx];
@itemnum = @itemnum[@idx];
@rf = @rf[@idx];
@rff = @rff[@idx];
@isaf = @isaf[@idx];
@times = @times[@idx];
@timesn = @timesn[@idx];

# Create table body
if ($nr > 0) {
	for ($i=0; $i <= $nr-1; $i++) {
		if ($isaf[$i] eq "1") { $iid = "$rf[$i]"; }
		else { $iid = "$rf[$i]"; }
		
		if ($i==0) {
			$newlines[$i] = "\\raisebox{\\ht\\strutbox}{\\hypertarget{itemnumberlist$itemnum[$i]}{}}\\itemreref{$itemnum[$i]} & \\path{$iid} & $times[$i]";
		} else {
			$newlines[$i] = "\\\\ \\raisebox{\\ht\\strutbox}{\\hypertarget{itemnumberlist$itemnum[$i]}{}}\\itemreref{$itemnum[$i]} & \\path{$iid} & $times[$i]";
		}
	}
}
my $newline = join('', @newlines);

# Use the lines below to have LIST OF ITEMS on the first page ONLY of the itemlist table
# Use \@{} on left/right side of table specification to remove whitespace around table
my $retstr = "
\\renewcommand{\\csvtable}{
\\catcode`\\%=12 \\catcode`\\#=12
\\begin{longtable*}{\@{}p{1.15cm}\@{\\mysp}p{\\maxwidth-2\\tabcolsep-2.35cm-1.15cm}\@{\\mysp}\@{\\extracolsep{\\fill}}*{1}{>{\\raggedleft\\arraybackslash}p{2.35cm}}\@{}}
	\\toprule $header \\\\\\toprule\\endfirsthead
	\\toprule $header \\\\\\toprule\\endhead
	\\endfoot\\bottomrule\\endlastfoot
	 $newline
\\end{longtable*}
\\catcode`\\%=14 \\catcode`\\#=6
}";
$retstr =~ s/[\t,\n]//g;

if ($dotime==1) {$retstr = "\\renewcommand{\\itemlistname}{LIST OF ITEMS (BY MODIFICATION TIME)}$retstr";}

# Return table command
return "$retstr";
}
\perlnewcommand{\makesubfigopt}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];

my @letters = < a b c d e f g h i j k l m n o p q r s t u v x y z A B C D E F G H I J K L M N O P Q R S T U V X Y Z >;
my $i = 0; my $outstr = "";
if ( $str =~ /^[\n ]*$/ ) {
	for ($i = 0; $i < @letters; $i++) { $outstr = "$outstr\\edef\\optsubfig$letters[$i]\{scale\=1\}";	}
} elsif ($str =~ /[\[\|]+/) {
	$str =~ s/(\|)+/ /g;
	$str =~ s/(\s{0,}&\s{0,})/ /g;
	$str =~ s/\[/$i++ >= @letters ? "[": "\\edef\\optsubfig$letters[$i-1]\{"/eg;
	$str =~ s/]/}/g;
	$outstr = $str;
} else {
	for ($i = 0; $i < @letters; $i++) { $outstr = "$outstr\\edef\\optsubfig$letters[$i]\{$str\}"; }
}

return "$outstr";
}
\perlnewcommand{\makesubfig}[4]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");

my $str = $_[0];
my $lbl = $_[1];
my $cap = $_[2];
my $figcapbelow = $_[3];

my $isbreak;
if ($str =~ /\|\|/){
	$isbreak = 1;
} else {
	$isbreak = 0;
}

$str =~ s/\.\./myveryuniquedoubledot/g;
$lbl =~ s/^ *//g;
$lbl =~ s/ *\[ */\[/g;
$lbl =~ s/ *\] /\]/g;
my @letters = < a b c d e f g h i j k l m n o p q r s t u v x y z A B C D E F G H I J K L M N O P Q R S T U V X Y Z >; my $i = 0; my @lbllst; 
if ((index($lbl, '&') != -1) || (index($lbl, '|') != -1)) {
	$lbl =~ /^ *([^\[]{1,}) *\[/; my $lblmain = $1; $lbl =~ s/^$lblmain//g;
	@lbllst = ($lbl =~ /\[ *([^\[\]]{1,}) *\]/g);
	$str =~ s/(RA[0-9]{3,})| *([^\&\|]+\.[a-zA-Z0-9]+) */$i++ >= @letters ? "": " \\checkartifact{$1$2} \\subcaptionbox\[\]{\\ifitemid\\itemid{$1$2}\\fi \\label{$lbllst[$i-1]}}{\\ifx\\fname\\empty ITEM \\renewcommand{\\newunderscorename}{}\\fixunderscore{$1$2}\\newunderscorename{} NOT FOUND \\else \\expandafter\\includegraphics\\expandafter\[\\optsubfig$letters[$i-1]\]{\\fname}\\fi} myveryuniquemarker$letters[$i-1]"/eg;
	$str =~ s/&/\\hspace{0cm}/g;
	if ($figcapbelow == 1) {
		$str =~ s/\|\|/\\pagebreak\\end{figure} \\clearpage \\begin{figure}[H] \\ContinuedFloat/g;
	} else {
		$str =~ s/\|\|/\\pagebreak\\end{figure} \\clearpage \\begin{figure}[H] \\ContinuedFloat \\caption[]{$cap}/g;
	}
	$str =~ s/\|/\\\\\\vspace{0.4\\myspacer}/g;
	if ($figcapbelow == 1) {
		$str =~ s/myveryuniquemarkera/\\figlabelpl{$cap}{$lblmain}/g;
		$str =~ s/myveryuniquemarker[a-z]/\\caption[]{$cap}/g;
	} else {
		$str = "\\figlabelpl{$cap}{$lblmain} $str";
		$str =~ s/myveryuniquemarker[a-z]//g;
	}
}
else {
	$str =~ s/(RA[0-9]{3,})| *([^\&\|]+\.[a-zA-Z0-9]+) */$i++ >= @letters ? "": " \\checkartifact{$1$2} \\subcaptionbox\[\]{\\ifitemid\\itemid{$1$2}\\fi \\label{$lbl$letters[$i-1]}}{\\ifx\\fname\\empty ITEM \\renewcommand{\\newunderscorename}{}\\fixunderscore{$1$2}\\newunderscorename{} NOT FOUND \\else \\expandafter\\includegraphics\\expandafter\[\\optsubfig$letters[$i-1]\]{\\fname} \\fi} myveryuniquemarker$letters[$i-1]"/eg;
	$str =~ s/&/\\hspace{-1cm}/g;
	if ($figcapbelow == 1) {
		$str =~ s/\|\|/\\pagebreak\\end{figure} \\clearpage \\begin{figure}[H] \\ContinuedFloat/g;
	} else {
		$str =~ s/\|\|/\\pagebreak\\end{figure} \\clearpage \\begin{figure}[H] \\ContinuedFloat \\caption[]{$cap}/g;
	}
	$str =~ s/\|/\\\\\\vspace{0.4\\myspacer}/g;
	if ($figcapbelow == 1) {
		$str =~ s/myveryuniquemarkera/\\figlabelpl{$cap}{$lbl}/g;
		$str =~ s/myveryuniquemarker[a-z]/\\caption[]{$cap}/g;
	} else {
		$str = "\\figlabelpl{$cap}{$lbl} $str";
		$str =~ s/myveryuniquemarker[a-z]//g;
	}
	
}
$str =~ s/myveryuniquedoubledot/\.\./g;
$str = "$str \\footnotesize \\iffigcapbelow\\else\\\\[0.4\\myspacer]\\fi \\iffigcapbelow\\quad\\\\[-0.4\\myspacer]\\fi";

return "$str";
}
\perlnewcommand{\printlstlisting}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $lstchar = '\x{00A1}\x{00A2}\x{00A3}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B4}\x{00B6}\x{00B7}\x{00B8}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', $file; my $str = do { local $/; <$lines> }; close $lines;

# Supports $lstchar as well with listingsutf8, but there seems to be a few bugs in the package
$str = fix_latin($str);
$str =~ s/([^$asciichar$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} }

my $n = 65;
$str =~ s/(.{1})(\1{65})/$1$2 /g; # put in spaces every $1 character in long lines with repeated characters, e.g. * in NONMEM

open(FILE, '>:utf8', 'file.tmp.txt');
print FILE "$str";
close(FILE);
return
}
\perlnewcommand{\printtmplisting}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $artid = $_[0];
open(FILE, '>:utf8', 'file.tmp.txt');
print FILE "ITEM $artid NOT FOUND";
close(FILE);
return
}
\perlnewcommand{\pdfloadfile}[3]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encoding::FixLatin qw(fix_latin);
my $data; my $page; my $ang; my $dima; my $dimb; my $string;my $level; my $section; my $stringc;
my $cpage; my $sec; my $doprint; my $curpdfpage; my $douse; my $islst; my $fbase;
my $pdfmakeinclude = ''; my $pdfmakebookmark = ''; my $pdfmakecontents = '';
$fbase = $_[0];
$section = $_[1];
$curpdfpage = $_[2];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

open(FILE, '<', "$fbase.pay");
while (<FILE>) {
    $data .= $_;
}
close(FILE);
while ($data =~ m/PageMediaNumber: (\d*\.?\d+)\nPageMediaRotation: (\d*\.?\d+)\nPageMediaRect: (\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)/g) {
	$page = $1;	$ang = $2; $dima = $5; $dimb = $6;
	if ( ((($ang == 90) || ($ang == 270)) && ($dimb > $dima) ) || (($ang == 0) && ($dima > $dimb)) ) {$pdfmakeinclude = "$pdfmakeinclude\\includepdf[pages={$page},landscape,pagecommand={\\pdflmark\\hypertarget{pmxapp$section.$page}{}}]{$fbase.pdf}\n";}
	else {$pdfmakeinclude = "$pdfmakeinclude\\includepdf[pages={$page},pagecommand={\\pdfmark\\hypertarget{pmxapp$section.$page}{}}]{$fbase.pdf}\n";}
}
while ($data =~ m/BookmarkTitle: (.*)\nBookmarkLevel: (\d*\.?\d+)\nBookmarkPageNumber: (\d*\.?\d+)/g) {
	$string  = $1; $level = 1+$2; $page = $3; $stringc = $string;
	$cpage = $curpdfpage+$page;
	
	# Replace: |~|\|{|}|%|$|&|#| for PDF bookmarks
	$string =~ s/\\/\\back\\{\\}/g;
	$string =~ s/\#/\\#/g;
	$string =~ s/\%/\\%/g;
	$string =~ s/\_/\\\_/g;
	$string =~ s/\^/\\^\{\}/g;
	$string =~ s/\&/\\&/g;
	$string =~ s/\{/\\{/g;
	$string =~ s/\}/\\}/g;
	$string =~ s/\$/\\\$/g;
	$string =~ s/\~/\\string\~/g;

	# Write PDF input command \pdfmakeinclude and bookmarks command \pdfmakebookmark
	if ($level == 2) {$sec = 'subsection';} elsif ($level == 3) {$sec = 'subsubsection';} elsif ($level == 4) {$sec = 'paragraph';} elsif ($level == 5) {$sec = 'subparagraph';}
	if (index(lc($string), lc('cover page')) != -1) {$doprint = 0;}
	elsif (index(lc($string), lc('approval page')) != -1) {$doprint = 0;}
	elsif (index(lc($string), lc('synopsis')) != -1) {$doprint = 0;}
	elsif (index(lc($string), lc('table of contents')) != -1) {$doprint = 0;}
	else {$doprint = 1;}
	if (index(lc($string), lc('list of tables')) != -1) {$islst = 1; $douse = 1;}
	elsif (($islst) && ($level==3)) {$islst = 1; $douse = 0;}
	elsif (index(lc($string), lc('list of figures')) != -1) {$islst = 1; $douse = 1;}
	elsif (($islst) && ($level==3)) {$islst = 1; $douse = 0;}
	else {$islst = 0; $douse = 1;}
	if ($level <= 5) {$pdfmakebookmark = "$pdfmakebookmark\\bookmark[level=$level,page=$cpage]{$string}\n";}

	# Special string replacement of |~|\|{|}|%|$|&|#| for table of contents
	$stringc =~ s/\\/myveryuniquenameofabackslash/g;
	$stringc =~ s/\#/\\#/g;
	$stringc =~ s/\%/\\%/g;
	$stringc =~ s/\_/\\\_/g;
	$stringc =~ s/\^/\\^\{\}/g;
	$stringc =~ s/\&/\\&/g;
	$stringc =~ s/\{/\\{/g;
	$stringc =~ s/\}/\\}/g;
	$stringc =~ s/\$/\\\$/g;
	$stringc =~ s/\~/\\\@backslashchar string~/g;
	$stringc =~ s/myveryuniquenameofabackslash/\\\@backslashchar textbackslash{}/g;

	# Write table of contents command \pdfmakecontents
	if (($level <= 5) && ($doprint) && ($douse)) {$pdfmakecontents = "$pdfmakecontents\\addtocontents{toc}{\\\@backslashchar contentsline {$sec}{$stringc}{$cpage}{pmxapp$section.$page}}\n";}
}

my $mkfile = 0; my $file = "$fbase.paz";
my $str = "\\renewcommand{\\pdfmakeinclude}{$pdfmakeinclude}\\renewcommand{\\pdfmakebookmark}{$pdfmakebookmark}\\renewcommand{\\pdfmakecontents}{$pdfmakecontents}";

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ( $str =~ /[^$asciichar]+/ ) { $mkfile = 1; $str = $tmpstr; }

if ( $mkfile == 1 ) {
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
	return "\\input{$file}";
} else {
	return "$str";
}
}
\perlnewcommand{\fixpax}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $paxfile = $_[0];
if ( ! -e "$paxfile.pax" ) {
	system("paxify \"$paxfile.pdf\"");
	open my $fh, '<:raw', "$paxfile.pax"; my $str = do { local $/; <$fh> }; close $fh;
	$str =~ s/\\\[\{dest\}\{([0-9]+)\}\{([0-9]+)\}\{FitR\}\{\n  Rect=\{([+-]?([0-9]*[.])?[0-9]+) ([+-]?([0-9]*[.])?[0-9]+) [+-]?([0-9]*[.])?[0-9]+ [+-]?([0-9]*[.])?[0-9]+\},\n\}\\\\/\\\[\{dest\}\{$1\}\{$2\}\{XYZ\}\{\n  DestY=\{$5\},DestX=\{$3\},\n\}\\\\/g;
	open(FILE, '>:utf8', "$paxfile.pax");
	print FILE "$str";
	close(FILE);
}
if ( ! -e "$paxfile.pay" ) {
	system("pdftk \"$paxfile.pdf\" dump_data_utf8 > \"$paxfile.pay\"");
}
return "";
}
\perlnewcommand{\addsynsec}[3]{
my $mysyncnt = $_[0];
my $mysynlev = $_[1];
my $mysynstr = $_[2];
$mysynstr =~ s/:$//g;
if ($mysyncnt eq "none") {$mysyncmd = "$mysyncmd"}
else {$mysyncmd = "$mysyncmd\\bookmark[level=$mysynlev,dest=mysynhyper$mysyncnt]{$mysynstr}\n";}
return "\\renewcommand{\\cussyncmd}{$mysyncmd}"
}
\perlnewcommand{\createfiles}[7]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $OS = "$^O";

my $name = $_[0];
my $docname = $_[1];
my $artifacts = $_[2];
my $dogetartifacts = $_[3];
my $doprintsig = $_[4];
my $missingrfiles = $_[5];
my $sigpages = $_[6];

my $narti = () = $artifacts =~ /,/gi; $narti = $narti + 1;
$docname =~ s/\\xspace *//g;

# Print list of missing files (non-artifacts)
my @mrf = split "myveryuniqueseparator", $missingrfiles; #@mrf = @mrf[1..$#mrf];
@mrf = uniq(@mrf); my $nmrf = scalar @mrf; unlink 'missingfiles.txt';
if ( $nmrf > 0 ) {
	open(FILE, '>:utf8', 'missingfiles.txt');
	print FILE join( ",", @mrf );
	close(FILE);
}

# Print list of artifacts to download
my @arti = split ",", $artifacts;
@arti = uniq(@arti);
if ($dogetartifacts == 1) {
	open(FILE, '>:utf8', 'missingartifacts.txt');
	print FILE join( ",", @arti );
	close(FILE);
}
else { unlink 'missingartifacts.txt'; }

# Print finalize.pl for cleaning up after a run. Not used: \nunlink <RA*_*>;
my $noerr;
if ( $OS eq 'MSWin32' ) { $noerr = '>nul 2>&1'; } else { $noerr = '2>/dev/null'; }
open(FILE, '>:utf8', 'finalize.pl');
print FILE "use strict;\nuse warnings;\nuse File::Copy qw(copy);\n";
if ($doprintsig == 1) {print FILE "system('pdftk A=\"$name.pdf\" cat A$sigpages output sigpage.pdf');\n";}
if (-e "$name.pdf") {
	print FILE "if ( system('qpdf --linearize \"$name.pdf\" \"tmp$name.pdf\" $noerr') ) \{ print STDERR \"LaTeX Warning: Program qpdf not found or not installed. Web optimization of PDF skipped...\\n\" \}\n";
	print FILE "if ( -e \"tmp$name.pdf\") \{ copy \"tmp$name.pdf\", \"$name.pdf\"; copy \"tmp$name.pdf\", \"$docname.pdf\"; unlink \"tmp$name.pdf\"; \}\n";
	print FILE "if (\! -e \"$docname.pdf\") \{ copy \"$name.pdf\", \"$docname.pdf\"; \}\n";
	print FILE "if ( \"$docname.pdf\" ne \"$name.pdf\" ) \{ open(FILENEW, '\>\:utf8', 'dodel.txt'); close(FILENEW); \}";
}
close(FILE);

return
}
\perlnewcommand{\fixnewline}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];
my $doitemid = $_[1];
$str =~ s/\\newline *\{ *\}/\\newline/g;
if ($doitemid==0) { $str =~ s/^( *\\newline *)*//g; }
$str =~ s/\\newline/\\phantom\{\}\\newline\{\}/g;
# $str =~ s/\\\\/\\phantom\{\}\\newline\{\}/g;
$str =~ s/((\\phantom *\{ *\})* *\\newline *(\{ *\})* *)+$//g;
$str =~ s/ +/ /g;
$str =~ s/^ //g;
$str =~ s/ $//g;
return "\\renewcommand{\\myfloatdescription}{$str}";
}
\perlnewcommand{\nlmixr}[1]{
use strict;
use warnings;
use File::Path;
use Path::Tiny;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $dir = $_[0];
(my $run) = $dir =~ /\/*([^\/]+)$/;
my $Run = ucfirst($run);

my $file; my $str; my $tab; my $hbod; my $cap; my $align; my $head; my $body; my $key; my $i; my $j; my $k; my $l; my $n; my $output;
my @files; my @fig; my @path; my @ext; my @output;

@files = glob "$dir/*.tex.rawtex";

$l = 0;
for ($k = 0; $k < @files; $k++) {
	$file = $files[$k];
	$str = path($file)->slurp;
	($key) = $file =~ /\/*([^\/]+)\.tex\.rawtex/;
	if (index($str, '\begin{longtable}') != -1) {
		($cap) = $str =~ /\\caption\{(.+)\}\\\\/; $cap = ucfirst($cap);
		($align) = $str =~ /\\begin\{longtable\}\{(.+)\}/;
		($head) = $str =~ /\\toprule\n(.+)\\\\/;
		($body) = $str =~ /\n\\endhead\n((.+\n)+)\\bottomrule/; $body = substr($body, 0, -4);
		$tab = "$dir/tables/$key.tex";
		$hbod = "$head \\\\\n$body";
		if ( -e "$dir/tables" ) { rmtree("$dir/tables"); }
		mkdir("$dir/tables");
		open(FILE, '>:utf8', "$dir/tables/$key.tex");
		print FILE "$hbod";
		close(FILE);
		$output[$l] = "\\pmxtable\n{$dir/tables/$key.tex}\n{tex}\n{$align}\n{tab:$run-$key}\n{$Run: $cap}\n{Table output from nlmixr.}\n{}\n\n";
		$l++;
	} elsif (index($str, '\begin{figure}') != -1) {
		($cap) = $str =~ /\\caption\{(.+)\}/; $cap = ucfirst($cap);
		@path = ($str =~ /\\includegraphics\{\{\"(.+)\"\}\..+\}\\\\/g);
		@ext = ($str =~ /\\includegraphics\{\{\".+\"\}\.(.+)\}\\\\/g);
		@fig = < >;
		for ($i = 0; $i < @path; $i++) { $fig[$i] = "$dir/$path[$i].$ext[$i]"; }
		$n = scalar(@fig);
		if ( $n > 1 ) {
			for ($i = 0; $i < @fig; $i++) {
				$j = $i + 1;
				$output[$l] =  "\\pmxfigure\n{$fig[$i]}\n{fig:$run-$key$j}\n{$Run: $cap ($j of $n)}\n{Figure output from nlmixr.}\n{width=\\maxwidth}\n\n";
				$l++;
			}
		} else {
			$output[$l] =  "\\pmxfigure\n{$fig[0]}\n{fig:$run-$key}\n{$Run: $cap}\n{Figure output from nlmixr.}\n{width=\\maxwidth}\n\n";
			$l++;
		}
	} else {
		
	}
}

$dir =~ s/\//-/g; $dir =~ s/\.//g; $dir =~ s/[a-zA-Z]+://g; $dir =~ s/^-//g;
$output = "@output"; $output =~ s/\n /\n/g; $output =~ s/\n\n$//g;
open(FILE, '>:utf8', "nlmixr-$dir.tex");
print FILE $output;
close(FILE);

return;
}
\perlnewcommand{\saveeqnfile}[7]{
use strict;
use warnings;
use File::Path;
use File::Copy qw(copy);
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $file = $_[0];
my $env = $_[1];
my $num = $_[2];
my $job = $_[3];
my $font = $_[4];
my $mathscwin = $_[5];
my $mathsclin = $_[6];
my $OS = "$^O";

my $scale;
if ( $OS eq 'MSWin32' ) { $scale = 1*$mathscwin;  } else { $scale = 1*$mathsclin; } # original: 72/288;
$scale = $font/12*$scale;

open my $fh, '<:raw', "$file"; my $str = do { local $/; <$fh> }; close $fh;
$str =~ s/\r//g;
$str =~ s/%/myveryuniquepercent/g;
# $str =~ s/%[^\n]*\n//g;
$str =~ s/\n/myveryuniquenewline/g;

if ( $num eq '' ){
	$num = "";
} else {
	$num = "{$num}";
}

my $subb = ''; my $sube = ''; my $lab = ''; my $envv = ''; my $name = ''; my $star = ''; my $labsp = '';
if ( $env eq 'subequations' ) {
	($env) = $str =~ /\\end\{(align|align\*|alignat|alignat\*|equation|equation\*|eqnarray|eqnarray\*|gather|gather\*|multline|multline\*|flalign|flalign\*)\}/;
	($num) = $str =~ /\\begin\{$env\}(\{[0-9]*\})/;
	($lab) = $str =~ /^.*(\\label\[*[^\[\]\{\}]*\]*\{[^\{\}]+\}).*\\begin\{\Q$env\E\}/;
	$str =~ s/\Q$lab\E//g;
	if ( "$lab" ne "" ) { $labsp = "\n"; }
	$subb = "\\begin{oldsubequations}\n";
	$sube = "\n\\end{oldsubequations}";
}
($envv) = $env =~ /([^\*]+)\**/;
($star) = $env =~ /[^\*]+(\**)/;
$star =~ s/\*/\\nonumber/g;
($name) = $file =~ /(.+)\.[^.]+$/;
$str =~ s/\\begin\{\Q$env\E\}(\{[0-9]*\})*//g;
$str =~ s/\\end\{\Q$env\E\}(\{[0-9]*\})*//g;

$str =~ s/\\\\(?=(?:(?!\\begin\{([^\{\}]+)\}|\\end\{([^\{\}]+)\}).)*\\end\{([^\{\}]+)\})/myveryuniquedoublebackslash/g;
$str = "\\\\$str";
my @lst = ( $str =~ /\\\\((?:(?!\\\\).)*)/g );
my $i; my $j; my $nlin = scalar @lst; my $nline = $nlin - 1; my $nl; my $namei; my $ref = ''; my $nn;
copy 'PharmTeX.fmt', 'PharmTeX-eqnbackup.fmt';
copy 'PharmTeX.log', 'PharmTeX-eqnbackup.log';
copy 'useroptions.txt', 'useroptions-eqnbackup.txt';
copy 'useroptionscomp.txt', 'useroptionscomp-eqnbackup.txt';
open(FILE, '>:utf8', "$file");
print FILE "$subb$lab$labsp\\begin{oldalign}\n";
for ($i=0; $i <= $nline; $i++) {
	$j = $i + 1;
	$namei = "$name-$j";
	$lst[$i] =~ s/myveryuniquenewline/\n/g;
	$lst[$i] =~ s/myveryuniquepercent/%/g;
	$lst[$i] =~ s/myveryuniquedoublebackslash/\\\\/g;
	$lst[$i] =~ s/\n+/\n/g;
	$lst[$i] =~ s/^\n//g;
	$lst[$i] =~ s/\n$//g;
	($ref) = $lst[$i] =~ /(\\label\{[^\{\}]+\})/;
	($nn) = $lst[$i] =~ /(\\nonumber)/;
	if (! defined $nn) {$nn = '';}
	open(FILEI, '>:utf8', "$namei.tex");
	print FILEI "\\documentclass[nocoverpage,nosigpage,noqapage,nosynopsis,notoc,noloa,nolot,nolof,noglossary,noitemid]{PharmTeX}\n\\usepackage{PharmTeX}\n\\IfFileExists{preamble.Rnw}{\\input{preamble.Rnw}}{\\IfFileExists{preamble.tex}{\\input{preamble.tex}}{}}\\pagestyle{empty}\n\\begin{document}\n\\begin{$envv*}$num\n$lst[$i]\n\\end{$envv*}\n\\references\n\\appendix\n\\itemlist\n\\end{document}";
	close(FILEI);
	if ( $i < $nline ) { $nl = "\\\\"; } else { $nl = ''; }
	print FILE "&\\vcenter{\\hbox{\\raisebox{-1.5\\ht\\strutbox}{\\includegraphics[scale=$scale]{$namei.png}}}}$nn$star$ref$nl\n";
	if ( $OS eq 'MSWin32' ) { system("perl %PHARMTEXDIR%\\runlatex.pl \"$namei.tex\" eqn"); } else { system("perl \$PHARMTEXDIR/runlatex.pl \"$namei.tex\" eqn"); }
	system("pdfcrop \"$namei.pdf\"");
	system("pdftopng -r 600 \"$namei-crop.pdf\" \"$namei.png\"");
	copy "$namei.png-000001.png", "$namei.png";
	unlink (<"$namei.png-*.png">, ("$namei.png-000002.png", "$namei-crop.pdf", "$namei.pdf", "$namei.tex", "$namei.aux", "$namei.log", "$namei.topl", "$namei.frpl", "$namei.tfpl", "$namei.ffpl", "$namei.dfpl", "$namei.lgpl", "$namei.pipe", "$namei.xtr", "$namei.glo", "$namei.ist", "$namei.synctex.gz", "texput.log"));
}
print FILE "\\end{oldalign}$sube";
close(FILE);
copy 'PharmTeX-eqnbackup.fmt', 'PharmTeX.fmt';
copy 'PharmTeX-eqnbackup.log', 'PharmTeX.log';
copy 'useroptions-eqnbackup.txt', 'useroptions.txt';
copy 'useroptionscomp-eqnbackup.txt', 'useroptionscomp.txt';
unlink ('PharmTeX-eqnbackup.fmt', 'PharmTeX-eqnbackup.log', 'useroptions-eqnbackup.txt', 'useroptionscomp-eqnbackup.txt');

open(FILEII, '>:utf8', "eqnimg.txt");
close(FILEII);

return;
}
\perlnewcommand{\savemathfiles}[3]{
use strict;
use warnings;
use File::Path;
use File::Copy qw(copy);
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $job = $_[0];
my $mathscwin = $_[1];
my $mathsclin = $_[2];
my $OS = "$^O";

my $scale; my $name; my $fh; my $str; my $jobstr; my @newcmd; my $newcmd; my @files; my $file; my $donum; my $raise; my $font;
if ( $OS eq 'MSWin32' ) { $scale = 0.94*$mathscwin;  } else { $scale = 0.94*$mathsclin; } # original: 72/288;

if (( -e "$job-math-1.tex" ) && ( -e "$job.bbl" ) && ( ! -e "$job-math-1.png" )) {

copy 'PharmTeX.fmt', 'PharmTeX-eqnbackup.fmt';
copy 'PharmTeX.log', 'PharmTeX-eqnbackup.log';
copy 'useroptions.txt', 'useroptions-eqnbackup.txt';
copy 'useroptionscomp.txt', 'useroptionscomp-eqnbackup.txt';

@files = <"$job-math*.tex">;
foreach $file (@files) {
	($name) = $file =~ /(.+)\.[^.]+$/;
	open $fh, '<:raw', "$file"; $str = do { local $/; <$fh> }; close $fh;
	($font) = $str =~ /myuniquefontstart=(.+?)myuniquefontend/;
	$str =~ s/myuniquefontstart=.+?myuniquefontend//g;
	$scale = $font/12*$scale;
	open(FILE, '>:utf8', "$name.tex");
	$raise = '-0.1';
	if ( $str =~ /^\^/ ) {
		$str =~ s/^(\^)/\{\\color{white\}.}\\hspace\{-3pt\}$1/g;
		$raise = '-0.08';
	}
	if ( $str =~ /^\_|\\s/ ) {
		$str =~ s/^(\_|\\s)/\{\\color{white\}.}\\hspace\{-3pt\}$1/g;
		$raise = '-0.16';
	}
	print FILE "\\documentclass[nocoverpage,nosigpage,noqapage,nosynopsis,noloa,notoc,nolot,nolof,noglossary,noitemid]{PharmTeX}\n\\usepackage{PharmTeX}\n\\IfFileExists{preamble.Rnw}{\\input{preamble.Rnw}}{\\IfFileExists{preamble.tex}{\\input{preamble.tex}}{}}\n\\pagestyle{empty}\n\\begin{document}\n\\ensuremath{$str}\n\\references\n\\appendix\n\\itemlist\n\\end{document}";
	close(FILE);
	if ( $OS eq 'MSWin32' ) { system("perl %PHARMTEXDIR%\\runlatex.pl \"$name.tex\" eqn"); } else { system("perl \$PHARMTEXDIR/runlatex.pl \"$name.tex\" eqn"); }
	system("pdfcrop \"$name.pdf\"");
	system("pdftopng -r 600 \"$name-crop.pdf\" \"$name.png\"");
	copy "$name.png-000001.png", "$name.png";
	unlink (<"$name.png-*.png">, ("$name-crop.pdf", "$name.pdf", "$name.tex", "$name.aux", "$name.log", "$name.topl", "$name.frpl", "$name.tfpl", "$name.ffpl", "$name.dfpl", "$name.lgpl", "$name.pipe", "$name.xtr", "$name.glo", "$name.ist", "$name.synctex.gz", "texput.log"));

	open(FILE, '>:utf8', "$name.tex");
	print FILE "\\raisebox{$raise\\ht\\strutbox}{\\includegraphics[scale=$scale]{$name.png}}";
	close(FILE);
}

copy 'PharmTeX-eqnbackup.fmt', 'PharmTeX.fmt';
copy 'PharmTeX-eqnbackup.log', 'PharmTeX.log';
copy 'useroptions-eqnbackup.txt', 'useroptions.txt';
copy 'useroptionscomp-eqnbackup.txt', 'useroptionscomp.txt';
unlink ('PharmTeX-eqnbackup.fmt', 'PharmTeX-eqnbackup.log', 'useroptions-eqnbackup.txt', 'useroptionscomp-eqnbackup.txt');

open(FILE, '>:utf8', "mathimg.txt");
close(FILE);

}

return;
}
\perlnewcommand{\nonemptyglossary}{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
open(FILE, '>:utf8', "nonemptyglossary.txt");
print FILE "";
close(FILE);
return;
}
\perlnewcommand{\fixunderscore}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $name = $_[0];
my $newname = $name;
$newname =~ s/\_/\\\_/g;
return "\\renewcommand{\\newunderscorename}{$newname}";
}
\perlnewcommand{\fixglscaption}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];
$str =~ s/\\gls/\\acrshort/g;
$str =~ s/\\Gls/\\Acrshort/g;
$str =~ s/\\glspl/\\acrshortpl/g;
$str =~ s/\\Glspl/\\Acrshortpl/g;
return "\\renewcommand{\\mypmxcaption}{$str}";
}
\perlnewcommand{\getpmxcolspec}[3]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $colspec = $_[0];
my $ncol = $_[1];
my $dcol = $_[2];

$colspec =~ s/[a-zA-Z]\{//g;
$colspec =~ s/\}//g;
my @cols = split ";", $colspec;

my @ishline; my $i; my $tmpstr;
my $out = 0;
for ($i=$ncol-1; $i < $ncol+$dcol-1; $i++) {
	$out = $out + $cols[$i];
}

# return "\\gdef\\mypmxindcolspec{$out}";
return "";
}
\perlnewcommand{\replacegls}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];
$str =~ s/\\gls/\\acrshort/g;
$str =~ s/\\Gls/\\Acrshort/g;
$str =~ s/\\glspl/\\acrshortpl/g;
$str =~ s/\\Glspl/\\Acrshortpl/g;
return "\\renewcommand{\\mypmxcaption}{$str}";
}
\perlnewcommand{\copytmppdffile}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $file = $_[0];
my ($fname) = $file =~ /\/*([^\/]+?)$/;
$fname =~ s/(.+)\..+?$/$1/g;
my $fbase = "$fname.tmppax";
$fname = "$fname.tmppax.pdf";
if (!-e $fname) { copy $file, $fname; }
return "\\renewcommand{\\fname}{$fname}\\renewcommand{\\fbase}{$fbase}";
}
\perlnewcommand{\loadlistofnumbers}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $file = $_[0];

open my $fh, '<:raw', $file; my $str = do { local $/; <$fh> }; close $fh;
$str =~ s/\r?\n?\z//g;
$str =~ s/\r?\n/\n/g;
my @lines = split "\n", $str;
@lines = @lines[ 1 .. $#lines ];
my $nline = scalar @lines; my $ncol;

my @nums = ("") x $nline; my @paths = @nums; my @vars = @nums; my @times = @nums;

for (my $i = 0; $i < $nline; $i++){
	my @cells = split "\t", $lines[$i];
	$ncol = scalar @cells;
	$nums[$i] = $cells[0];
	$paths[$i] = $cells[1];
	$vars[$i] = $cells[2];
	$times[$i] = $cells[3];
}

my $num = join('', @nums);
my $path = join('', @paths);
my $var = join('', @vars);
my $time = join('', @times);

$path =~ s/\\/\//g;

return "\\newcommand{\\pmxlonallnum}{$num}\\newcommand{\\pmxlonallpath}{$path}\\newcommand{\\pmxlonallvar}{$var}\\newcommand{\\pmxlonalltime}{$time}";
}
\perlnewcommand{\loadlistofnumbersvalue}[6]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");

my $num = $_[0];
my $path = $_[1];
my $var = $_[2];
my $time = $_[3];
my $namei = $_[4];
my $cnt = $_[5];

my @nums = split '', $num;
my @paths = split '', $path;
my @vars = split '', $var;
my @times = split '', $time;

my $rout; my $idx;
if ( grep( /^$namei$/, @vars ) ) {
	($idx) = grep { $vars[$_] ~~ $namei } 0 .. $#vars;
	$rout = "\\label{listofnumberslabel$cnt}\\raisebox{\\ht\\strutbox}{\\hypertarget{listofnumbersvalue$cnt}{}}\\iflon\\hyperlink{listofnumbersrow$cnt}{$nums[$idx]}\\else $nums[$idx]\\fi\\makeatletter\\g\@addto\@macro\\pmxlonnum{$nums[$idx]}\\g\@addto\@macro\\pmxlonpath{$paths[$idx]}\\g\@addto\@macro\\pmxlonvar{$vars[$idx]}\\g\@addto\@macro\\pmxlontime{$times[$idx]}\\makeatother";
} else {
	$rout = "\\label{listofnumberslabel$cnt}\\raisebox{\\ht\\strutbox}{\\hypertarget{listofnumbersvalue$cnt}{}}\\iflon\\hyperlink{listofnumbersrow$cnt}{R OUTPUT MISSING}\\else R OUTPUT MISSING\\fi\\makeatletter\\g\@addto\@macro\\pmxlonnum{MISSING}\\g\@addto\@macro\\pmxlonpath{MISSING}\\g\@addto\@macro\\pmxlonvar{MISSING}\\g\@addto\@macro\\pmxlontime{MISSING}\\makeatother";
}



return "$rout";
}
\perlnewcommand{\printlistofnumbers}[4]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");

my $num = $_[0];
my $path = $_[1];
my $var = $_[2];
my $time = $_[3];

$num =~ s/$//g;
$path =~ s/$//g;
$var =~ s/$//g;
$time =~ s/$//g;

my @nums = split '', $num;
my @paths = split '', $path;
my @vars = split '', $var;
my @times = split '', $time;

my $nrow = scalar @nums; my @lines; my $i;
for ($i = 0; $i < $nrow; $i++){
	$lines[$i] = "\\raisebox{\\ht\\strutbox}{\\hypertarget{listofnumbersrow$i}{}}\\hyperlink{listofnumbersvalue$i}{\\pageref*{listofnumberslabel$i}} & $nums[$i] & \\detokenize{$vars[$i]} & \\path{$paths[$i]} & $times[$i]";
}
my $header = 'PAGE & VALUE & VARIABLE & SOURCE & UPDATE (GMT)';
my $body = join(" \\\\ ", @lines);

my $retstr = "
\\catcode`\\%=12 \\catcode`\\#=12
\\begin{tabularx}{\\maxwidth}{\@{}l\@{\\mysp}l\@{\\mysp}l\@{\\mysp}L{0.6}\@{\\mysp}r\@{}}
	\\toprule $header \\\\\\toprule\\endfirsthead
	\\toprule $header \\\\\\toprule\\endhead
	\\endfoot\\bottomrule\\endlastfoot
	 $body
\\end{tabularx}
\\catcode`\\%=14 \\catcode`\\#=6";
$retstr =~ s/[\t,\n]//g;

return "$retstr";
}
\perlnewcommand{\checkpharmtex}{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $OS = "$^O";

my $pharmtexdir = $ENV{PHARMTEXDIR};
if ( $OS eq 'MSWin32' ) { $pharmtexdir =~ s/\\/\//g; }

return "\\newcommand{\\pharmtexdir}{$pharmtexdir}";
}
\perlnewcommand{\printdocpdfname}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $str = $_[0];

$str =~ s/\\xspace *//g;

open(FILE, '>:utf8', 'docpdfname.txt');
print FILE "$str";
close(FILE);
return;
}
\perlnewcommand{\fixinputfile}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $mkfile = 0;
open my $lines, '<:raw', $file or die "File \"$file\" not found"; my $str = do { local $/; <$lines> }; close $lines;

my $tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { if ( -e 'fixfiles' ) {print STDERR "LaTeX Warning: Unsupported symbol(s) in $file. Look for <?> in PDF.\n";} $mkfile = 1; $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { if ($mkfile==0) {$mkfile = 1; $str = $tmpstr;} }
if ( $str =~ /[^$asciichar]+/ ) { $mkfile = 1; $str = $tmpstr; }

if ($mkfile==1) {
	copy("$file", "$file.tmp.txt");
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
	return "\\input{$file}\\removeinputfile{$file}";
} else {
	return "\\input{$file}";
}
}
\perlnewcommand{\removeinputfile}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $file = $_[0];

copy("$file.tmp.txt", "$file");
unlink "$file.tmp.txt";

return;
}
\perlnewcommand{\checkemptybib}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $file = $_[0];

my $str; my $lines;
if ( -e "$file.blg" ) {
	open $lines, '<:raw', "$file.blg"; $str = do { local $/; <$lines> }; close $lines;
} else {
	$str = '';
}

if ( $str =~ /I found no \\citation commands/ ) {
	return "\\renewcommand{\\doprintbibliography}{0}";
} else {
	return;
}
}
\perlnewcommand{\fixlistof}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $job = $_[0];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $str; my $lines; my $tmpstr; my $file; my $teststr;

$file = "$job.toc";
if ( -e $file ) {
	open $lines, '<:raw', "$file"; $str = do { local $/; <$lines> }; close $lines;
	$tmpstr = fix_latin($str); $teststr = $str;
	$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
	eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
	if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }
	$str =~ s/\\cite[a-zA-Z]* *\{.+?\}//g;
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
}
$file = "$job.lof";
if ( -e $file ) {
	open $lines, '<:raw', "$file"; $str = do { local $/; <$lines> }; close $lines;
	$tmpstr = fix_latin($str); $teststr = $str;
	$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
	eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
	if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }
	$str =~ s/\\cite[a-zA-Z]* *\{.+?\}//g;
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
}
$file = "$job.lot";
if ( -e $file ) {
	open $lines, '<:raw', "$file"; $str = do { local $/; <$lines> }; close $lines;
	$tmpstr = fix_latin($str); $teststr = $str;
	$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
	eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
	if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }
	$str =~ s/\\cite[a-zA-Z]* *\{.+?\}//g;
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
}
$file = "$job.loa";
if ( -e $file ) {
	open $lines, '<:raw', "$file"; $str = do { local $/; <$lines> }; close $lines;
	$tmpstr = fix_latin($str); $teststr = $str;
	$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
	eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
	if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }
	$str =~ s/\\cite[a-zA-Z]* *\{.+?\}//g;
	open(FILE, '>:utf8', "$file");
	print FILE "$str";
	close(FILE);
}

return;
}
\perlnewcommand{\addmultibib}[1]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
my $num = $_[0];

my $str = ''; my $i; my $j;
my @a = ("a".."zz");

for ($i=0; $i < $num; $i++) {
	# $i = $num-1; $j = $num;
	$j = $i + 1;
	$str = "$str\n\\newcites\{XA$a[$i]\}\{References\}\\let\\oriciteyearXA$a[$i]\\citeyearXA$a[$i]\\RenewDocumentCommand\{\\citeyearXA$a[$i]\}\{O\{\} O\{\} m\}\{\\StrSubstitute\{#3\}\{,\}\{-XA$a[$i],\}\[\\tmpcitearg\]\\renewcommand\{\\citenumfont\}\[1\]\{A$j.##1\}\\begin{NoHyper}\\oriciteyearXA$a[$i]\[#1\]\[#2\]\{\\tmpcitearg-XA$a[$i]\}\\end{NoHyper}\\renewcommand\{\\citenumfont\}\[1]\{##1\}\}\\let\\oricitetXA$a[$i]\\citetXA$a[$i]\\RenewDocumentCommand\{\\citetXA$a[$i]\}\{O\{\} O\{\} m\}\{\\StrSubstitute\{#3\}\{,\}\{-XA$a[$i],\}\[\\tmpcitearg\]\\renewcommand\{\\citenumfont\}\[1\]\{A$j.##1\}\\oricitetXA$a[$i]\[#1\]\[#2\]\{\\tmpcitearg-XA$a[$i]\}\\renewcommand\{\\citenumfont\}\[1]\{##1\}\}\\let\\oriCitetXA$a[$i]\\CitetXA$a[$i]\\RenewDocumentCommand\{\\CitetXA$a[$i]\}\{O\{\} O\{\} m\}\{\\StrSubstitute\{#3\}\{,\}\{-XA$a[$i],\}\[\\tmpcitearg\]\\renewcommand\{\\citenumfont\}\[1\]\{A$j.##1\}\\oriCitetXA$a[$i]\[#1\]\[#2\]\{\\tmpcitearg-XA$a[$i]\}\\renewcommand\{\\citenumfont\}\[1]\{##1\}\}\\let\\oriciteXA$a[$i]\\citeXA$a[$i]\\RenewDocumentCommand\{\\citeXA$a[$i]\}\{O\{\} O\{\} m\}\{\\StrSubstitute\{#3\}\{,\}\{-XA$a[$i],\}\[\\tmpcitearg\]\\renewcommand\{\\citenumfont\}\[1\]\{A$j.##1\}\\oriciteXA$a[$i]\[#1\]\[#2\]\{\\tmpcitearg-XA$a[$i]\}\\renewcommand\{\\citenumfont\}\[1]\{##1\}\}\\ifdefined\\RefStyle\\bibliographystyleXA$a[$i]\{\\RefStyle\}\\else\\bibliographystyleXA$a[$i]\{unsrt\}\\fi";
}

return "$str";
}
\perlnewcommand{\fixmultibib}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];
my $num = $_[1];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $str; my $lines; my $tmpstr;

open $lines, '<:raw', "$file.bib" or die "File \"$file.bib\" not found"; $str = do { local $/; <$lines> }; close $lines;
$tmpstr = fix_latin($str); my $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }
$str =~ s/(\@.+?),/$1-$num,/g;
open(FILE, '>:utf8', "$num.bib");
print FILE "$str";
close(FILE);

return;
}
\perlnewcommand{\savefile}[2]{
use strict;
use warnings;
use open OUT => ':raw';
binmode(STDOUT, ":utf8");
use Encode;
use Encoding::FixLatin qw(fix_latin);
my $file = $_[0];
my $str = $_[1];

# List of non-standard UTF-8 characters supported by inputenc and fontenc in pdfLaTeX
my $asciichar = '|a-zA-Z\{\}\s%\.\/\-:;,0-9@=\\\\\"\'\(\)_~\$\!&\`\?+#\^<>\[\]\*';
my $utf8char = '\x{00A0}\x{00A1}\x{00A2}\x{00A3}\x{00A4}\x{00A5}\x{00A6}\x{00A7}\x{00A8}\x{00A9}\x{00AA}\x{00AB}\x{00AC}\x{00AD}\x{00AE}\x{00AF}\x{00B0}\x{00B1}\x{00B2}\x{00B3}\x{00B4}\x{00B5}\x{00B6}\x{00B7}\x{00B8}\x{00B9}\x{00BA}\x{00BB}\x{00BC}\x{00BD}\x{00BE}\x{00BF}\x{00C0}\x{00C1}\x{00C2}\x{00C3}\x{00C4}\x{00C5}\x{00C6}\x{00C7}\x{00C8}\x{00C9}\x{00CA}\x{00CB}\x{00CC}\x{00CD}\x{00CE}\x{00CF}\x{00D0}\x{00D1}\x{00D2}\x{00D3}\x{00D4}\x{00D5}\x{00D6}\x{00D7}\x{00D8}\x{00D9}\x{00DA}\x{00DB}\x{00DC}\x{00DD}\x{00DE}\x{00DF}\x{00E0}\x{00E1}\x{00E2}\x{00E3}\x{00E4}\x{00E5}\x{00E6}\x{00E7}\x{00E8}\x{00E9}\x{00EA}\x{00EB}\x{00EC}\x{00ED}\x{00EE}\x{00EF}\x{00F0}\x{00F1}\x{00F2}\x{00F3}\x{00F4}\x{00F5}\x{00F6}\x{00F7}\x{00F8}\x{00F9}\x{00FA}\x{00FB}\x{00FC}\x{00FD}\x{00FE}\x{00FF}\x{0100}\x{0101}\x{0102}\x{0103}\x{0104}\x{0105}\x{0106}\x{0107}\x{0108}\x{0109}\x{010A}\x{010B}\x{010C}\x{010D}\x{010E}\x{010F}\x{0110}\x{0111}\x{0112}\x{0113}\x{0114}\x{0115}\x{0116}\x{0117}\x{0118}\x{0119}\x{011A}\x{011B}\x{011C}\x{011D}\x{011E}\x{011F}\x{0120}\x{0121}\x{0122}\x{0123}\x{0124}\x{0125}\x{0128}\x{0129}\x{012A}\x{012B}\x{012C}\x{012D}\x{012E}\x{012F}\x{0130}\x{0131}\x{0132}\x{0133}\x{0134}\x{0135}\x{0136}\x{0137}\x{0139}\x{013A}\x{013B}\x{013C}\x{013D}\x{013E}\x{0141}\x{0142}\x{0143}\x{0144}\x{0145}\x{0146}\x{0147}\x{0148}\x{014A}\x{014B}\x{014C}\x{014D}\x{014E}\x{014F}\x{0150}\x{0151}\x{0152}\x{0153}\x{0154}\x{0155}\x{0156}\x{0157}\x{0158}\x{0159}\x{015A}\x{015B}\x{015C}\x{015D}\x{015E}\x{015F}\x{0160}\x{0161}\x{0162}\x{0163}\x{0164}\x{0165}\x{0168}\x{0169}\x{016A}\x{016B}\x{016C}\x{016D}\x{016E}\x{016F}\x{0170}\x{0171}\x{0172}\x{0173}\x{0174}\x{0175}\x{0176}\x{0177}\x{0178}\x{0179}\x{017A}\x{017B}\x{017C}\x{017D}\x{017E}\x{0192}\x{01CD}\x{01CE}\x{01CF}\x{01D0}\x{01D1}\x{01D2}\x{01D3}\x{01D4}\x{01E2}\x{01E3}\x{01E6}\x{01E7}\x{01E8}\x{01E9}\x{01EA}\x{01EB}\x{01F0}\x{01F4}\x{01F5}\x{0218}\x{0219}\x{021A}\x{021B}\x{0232}\x{0233}\x{02C6}\x{02C7}\x{02D8}\x{02DC}\x{02DD}\x{0E3F}\x{1E02}\x{1E03}\x{1E20}\x{1E21}\x{200C}\x{2010}\x{2011}\x{2012}\x{2013}\x{2014}\x{2015}\x{2016}\x{2018}\x{2019}\x{201A}\x{201C}\x{201D}\x{201E}\x{2020}\x{2021}\x{2022}\x{2026}\x{2030}\x{2031}\x{2039}\x{203A}\x{203B}\x{203D}\x{2044}\x{204E}\x{2052}\x{20A1}\x{20A4}\x{20A6}\x{20A9}\x{20AB}\x{20AC}\x{20B1}\x{2103}\x{2116}\x{2117}\x{211E}\x{2120}\x{2122}\x{2126}\x{2127}\x{212E}\x{2190}\x{2191}\x{2192}\x{2193}\x{2329}\x{232A}\x{2422}\x{2423}\x{25E6}\x{25EF}\x{266A}';
my $cuschar = '';

my $tmpstr; my $teststr;
$tmpstr = fix_latin($str); $teststr = $str;
$tmpstr =~ s/([^$asciichar$utf8char$cuschar])/<\?>/g; if ( defined $1 ) { $str = $tmpstr; }
eval { decode( "utf8", $teststr, Encode::FB_CROAK ) }; if ( $@ ) { $str = $tmpstr; }
if ( $str =~ /[^$asciichar]+/ ) { $str = $tmpstr; }

open(FILE, '>:utf8', "$file");
print FILE "$str";
close(FILE);

return;
}

\else

\IfFileExists{noperlfirst.txt}{\RequirePackage{noperltex}}{}
\newcounter{perlcount}\setcounter{perlcount}{0}

\newcommand{\findartifact}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\dotwice}{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\includetex}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\inputtext}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixbib}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixgls}[2]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\checkfile}[2]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\includecsv}[9]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\includemetacsv}[7]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\makesubfigopt}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\makesubfig}[4]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\printlstlisting}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\printtmplisting}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\pdfloadfile}[3]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixpax}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\addsynsec}[3]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\createfiles}[7]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixnewline}[1]{\addtocounter{perlcount}{1}\input{noperltex-\theperlcount}}
\newcommand{\nlmixr}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\saveeqnfile}[7]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\savemathfiles}[7]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\nonemptyglossary}{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixunderscore}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixglscaption}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\getpmxcolspec}[3]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\copytmppdffile}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\loadlistofnumbers}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\loadlistofnumbersvalue}[6]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\printlistofnumbers}[4]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\checkpharmtex}{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\printdocpdfname}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixinputfile}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\removeinputfile}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\checkemptybib}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\addmultibib}[1]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\fixmultibib}[2]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}
\newcommand{\savefile}[2]{\addtocounter{perlcount}{1}\oldinput{noperltex-\theperlcount}}

\fi

%%% Multibib package
\usepackage[resetlabels,labeled]{multibib}
\usepackage{morewrites}
\renewcommand{\@biblabel}[1]{#1\hfill} % left justify bibliography labels for regular bibliography
\setbiblabelwidth{10}

%%% Fix capitalization issue for \Citet with "numbers" and Natbib
\renewcommand\NAT@test[1]{%
 \@ifnum{#1=\@ne}{%
  \ifx\NAT@nm\NAT@noname
   \begingroup\reset@font\bfseries(author?)\endgroup
   \PackageWarning{natbib}{%
    Author undefined for citation`\@citeb' \MessageBreak on page \thepage%
   }%
  \else \NAT@nmfmt{\NAT@nm}%
  \fi
 }{%
  \if\relax\NAT@date\relax
   \begingroup\reset@font\bfseries(year?)\endgroup
   \PackageWarning{natbib}{%
    Year undefined for citation`\@citeb' \MessageBreak on page \thepage%
   }%
  \else \NAT@date
  \fi
 }%
}%

%%% Multibib package fix
\def\@mb@citenamelist{cite,citet,Citet,citeyear}
\def\newcites#1#2{%
  \def\@suffixlist{#1,}%
  \@for\@newrefname:=#2\do{%
    \mylop\@suffixlist\to\@suffix
    \expandafter\protected@edef\csname refname\@suffix\endcsname
      {\@newrefname}%
    \if@filesw
      \expandafter\newwrite\csname @auxout\@suffix\endcsname
      \expandafter\edef\csname @auxout\@suffix name\endcsname{\@suffix}%
      \begingroup
        \makeatletter
        \@input@{\csname @auxout\@suffix name\endcsname .aux}%
      \endgroup
      \immediate\openout\csname @auxout\@suffix\endcsname
                        \csname @auxout\@suffix name\endcsname .aux
    \fi
    \@for\@citename:=\@mb@citenamelist\do{%
      \expandafter\edef\csname \@citename\@suffix\endcsname{%
        \let\noexpand\@citex\noexpand\mb@@citex
        \let\noexpand\@newciteauxhandle\csname @auxout\@suffix\endcsname
        \noexpand\csname\@citename\endcsname}%
    }%
    \expandafter\edef\csname nocite\@suffix\endcsname##1{{%
      \let\noexpand\@auxout\csname @auxout\@suffix\endcsname
      \noexpand\nocite{##1}}}%
    \iflabeled % if option labeled
      \expandafter\edef\csname @bibitem\@suffix\endcsname##1{%
        \noexpand\item
        \noexpand\if@filesw \noexpand\immediate\noexpand\write\noexpand\@auxout
        {\noexpand\string\noexpand\bibcite{##1}%
           {\@suffix\noexpand\the\noexpand\value{\noexpand\@listctr}}}%
        \noexpand\fi
        \noexpand\ignorespaces}%
      \expandafter\edef\csname @biblabel\@suffix\endcsname##1{\noexpand\citelocation##1\hfill}%changed from [\@suffix##1]
    \fi % end if option labeled
    \expandafter\edef\csname bibliography\@suffix\endcsname##1{{%
      \let\noexpand\temp@auxout\noexpand\@auxout
      \let\noexpand\addtocontents\noexpand\mb@addtocontents
      \let\noexpand\@auxout\csname @auxout\@suffix\endcsname
      \let\noexpand\jobname
         \expandafter\noexpand\csname @auxout\@suffix name\endcsname
      \let\noexpand\refname
          \expandafter\noexpand\csname refname\@suffix\endcsname
      \let\noexpand\bibname
          \expandafter\noexpand\csname refname\@suffix\endcsname
      \iflabeled
        \let\noexpand\@bibitem
            \expandafter\noexpand\csname @bibitem\@suffix\endcsname
        \let\noexpand\@biblabel
            \expandafter\noexpand\csname @biblabel\@suffix\endcsname
      \fi
      \noexpand\bibliography{##1}%
      }}
    \expandafter\edef\csname bibliographystyle\@suffix\endcsname##1{%
      \noexpand\if@filesw
        \noexpand\immediate\noexpand\write\csname @auxout\@suffix\endcsname
          {\noexpand\string\noexpand\bibstyle{##1}}%
      \noexpand\fi}
   }%
}
\@onlypreamble\newcites

%%% Another fix for multibib, https://tex.stackexchange.com/questions/97991/multibib-indentation
%%% The problem is that multibib, with the resetlabels option, always passes 0 for computing the label width, which is an error, in my opinion. You can solve the issue with another patch:
\patchcmd{\thebibliography}{%
  \section*{\refname}\@mkboth{\MakeUppercase\refname}{\MakeUppercase\refname}%
}{}{}{}
\begingroup\catcode`#=12
\AtBeginDocument{
  \patchcmd\thebibliography
    {\advance\@tempcnta#1}
    {\advance\@tempcnta#1\else\@tempcnta#1}
    {}{}
}
\endgroup

\endinput
